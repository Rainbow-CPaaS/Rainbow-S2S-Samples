/**
 * Rainbow Enduser portal
 * # Rainbow end user portal API guide  ## Preamble  ### Introduction  This guide describes list of API services that are provided by OT Rainbow End user portal. This portal is dedicated to end user features.  ### Protocol  REST interface is used for sending/receiving OT rainbow API messages. HTTP requests GET, DELETE, POST, UPDATE are used. Standard HTTP responses are used to provide requested information or error status. There is no session notion in OT Rainbow system, so requests could be issued according stateless model, without transport conservation between them. Additional data could be provided in message body. JSON is used as a main format for data encoding in message body part. Each request is started with the following pattern /{module}/{version}/ where {module} is a portal module name to address and {version} is a version of used API, par example, “v1.0”.  ### Security considerations  Each request should contain some credential information to authenticate itself. Standard HTTP authentication with basic/bearer modes is used. JSON Web Token mechanism is used to provide authentication information. JWT has a expire timeout that is controlled by OT Rainbow portal to prevent very long token usage. Also authentication with application token is used. The token must be provided in the request HTTP header, using a custom header: APIKey. At server side, token is verified, and if it doesn’t match, 403 Not Allowed response is sent. TLS is used as a transport protocol to support message exchanges between OT Rainbow portal and an application.  
 *
 * The version of the OpenAPI document: 1.84.0
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 *
 * OpenAPI Generator version: 4.1.2
 *
 * Do not edit the class manually.
 *
 */

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['ApiClient', 'model/DeleteMyselfSuccess', 'model/GetConnectedUserDataSuccess', 'model/GetUserByJidSuccess', 'model/GetUserDataByIdSuccess', 'model/GetUserNetworkSuccess', 'model/GetUsersByloginEmails', 'model/GetUsersByloginEmailsSuccess', 'model/RegisterMyself', 'model/RegisterMyselfSuccess', 'model/RemoveContactFromUserNetworkSuccess', 'model/SearchUsersByJids', 'model/SearchUsersByJidsSuccess', 'model/UpdateUser', 'model/UpdateUserSuccess'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS-like environments that support module.exports, like Node.
    module.exports = factory(require('../ApiClient'), require('../model/DeleteMyselfSuccess'), require('../model/GetConnectedUserDataSuccess'), require('../model/GetUserByJidSuccess'), require('../model/GetUserDataByIdSuccess'), require('../model/GetUserNetworkSuccess'), require('../model/GetUsersByloginEmails'), require('../model/GetUsersByloginEmailsSuccess'), require('../model/RegisterMyself'), require('../model/RegisterMyselfSuccess'), require('../model/RemoveContactFromUserNetworkSuccess'), require('../model/SearchUsersByJids'), require('../model/SearchUsersByJidsSuccess'), require('../model/UpdateUser'), require('../model/UpdateUserSuccess'));
  } else {
    // Browser globals (root is window)
    if (!root.RainbowEnduserPortal) {
      root.RainbowEnduserPortal = {};
    }
    root.RainbowEnduserPortal.UsersApi = factory(root.RainbowEnduserPortal.ApiClient, root.RainbowEnduserPortal.DeleteMyselfSuccess, root.RainbowEnduserPortal.GetConnectedUserDataSuccess, root.RainbowEnduserPortal.GetUserByJidSuccess, root.RainbowEnduserPortal.GetUserDataByIdSuccess, root.RainbowEnduserPortal.GetUserNetworkSuccess, root.RainbowEnduserPortal.GetUsersByloginEmails, root.RainbowEnduserPortal.GetUsersByloginEmailsSuccess, root.RainbowEnduserPortal.RegisterMyself, root.RainbowEnduserPortal.RegisterMyselfSuccess, root.RainbowEnduserPortal.RemoveContactFromUserNetworkSuccess, root.RainbowEnduserPortal.SearchUsersByJids, root.RainbowEnduserPortal.SearchUsersByJidsSuccess, root.RainbowEnduserPortal.UpdateUser, root.RainbowEnduserPortal.UpdateUserSuccess);
  }
}(this, function(ApiClient, DeleteMyselfSuccess, GetConnectedUserDataSuccess, GetUserByJidSuccess, GetUserDataByIdSuccess, GetUserNetworkSuccess, GetUsersByloginEmails, GetUsersByloginEmailsSuccess, RegisterMyself, RegisterMyselfSuccess, RemoveContactFromUserNetworkSuccess, SearchUsersByJids, SearchUsersByJidsSuccess, UpdateUser, UpdateUserSuccess) {
  'use strict';

  /**
   * Users service.
   * @module api/UsersApi
   * @version 1.84.0
   */

  /**
   * Constructs a new UsersApi. 
   * @alias module:api/UsersApi
   * @class
   * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
   * default to {@link module:ApiClient#instance} if unspecified.
   */
  var exports = function(apiClient) {
    this.apiClient = apiClient || ApiClient.instance;



    /**
     * Deleted by himself
     * This API can be used to delete a user.    Depending current user initialization, the behaviour to follow may change   * user never initialized and never logged:    * delete the user from xmpp and database  * user currently initialized or logged at least one time    * The credentials of the account are destroyed to avoid a malicious reconnection. Then, change loginEmail, change rainbow password, change jid_password. All Rainbow clients connected using this account are disconnected   * Cancel pending invites from this user, to join rainbow   * set user flag 'isTerminated' and move him to the dedicated company 'Terminated'   * Rainbow sends a notification email to the professional email of the deleted account   * The deleted account remains visible by other Rainbow users. But It is no more possible to interact with it (no chat, no calls). Messages associated to the deleted user are still visible by other active Rainbow users   * A deleted user can't be find in the search   The following XMPP message is sent to all users being in deleted user's roster:        ```html    <message id=\"8413b42e-563c-4437-9a53-06f638b5ab69_0\" type=\"management\"        from=\"pcloud_enduser_1@openrainbow.com/172440802160413612281463752830017532\"        to=\"5abb735b2d3c4e50adde276c50ec489c@@openrainbow.com\"        xmlns=\"jabber:client\">        <useraccount id=\"56c5c19f94141765119f896c\" action=\"update\" xmlns=\"jabber:iq:configuration\"/>    </message> ```    **Only a migration script is planned to delete permanently a user 'terminated' after a legal delay time.**
     * @param {String} userId User unique identifier (like 56c5c19f94141765119f896c)
     * @param {String} accept application/json
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/DeleteMyselfSuccess} and HTTP response
     */
    this.deleteMyselfWithHttpInfo = function(userId, accept) {
      var postBody = null;
      // verify the required parameter 'userId' is set
      if (userId === undefined || userId === null) {
        throw new Error("Missing the required parameter 'userId' when calling deleteMyself");
      }
      // verify the required parameter 'accept' is set
      if (accept === undefined || accept === null) {
        throw new Error("Missing the required parameter 'accept' when calling deleteMyself");
      }

      var pathParams = {
        'userId': userId
      };
      var queryParams = {
      };
      var collectionQueryParams = {
      };
      var headerParams = {
        'accept': accept
      };
      var formParams = {
      };

      var authNames = ['Bearer'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = DeleteMyselfSuccess;
      return this.apiClient.callApi(
        '/api/rainbow/enduser/v1.0/users/{userId}', 'DELETE',
        pathParams, queryParams, collectionQueryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Deleted by himself
     * This API can be used to delete a user.    Depending current user initialization, the behaviour to follow may change   * user never initialized and never logged:    * delete the user from xmpp and database  * user currently initialized or logged at least one time    * The credentials of the account are destroyed to avoid a malicious reconnection. Then, change loginEmail, change rainbow password, change jid_password. All Rainbow clients connected using this account are disconnected   * Cancel pending invites from this user, to join rainbow   * set user flag 'isTerminated' and move him to the dedicated company 'Terminated'   * Rainbow sends a notification email to the professional email of the deleted account   * The deleted account remains visible by other Rainbow users. But It is no more possible to interact with it (no chat, no calls). Messages associated to the deleted user are still visible by other active Rainbow users   * A deleted user can't be find in the search   The following XMPP message is sent to all users being in deleted user's roster:        ```html    <message id=\"8413b42e-563c-4437-9a53-06f638b5ab69_0\" type=\"management\"        from=\"pcloud_enduser_1@openrainbow.com/172440802160413612281463752830017532\"        to=\"5abb735b2d3c4e50adde276c50ec489c@@openrainbow.com\"        xmlns=\"jabber:client\">        <useraccount id=\"56c5c19f94141765119f896c\" action=\"update\" xmlns=\"jabber:iq:configuration\"/>    </message> ```    **Only a migration script is planned to delete permanently a user 'terminated' after a legal delay time.**
     * @param {String} userId User unique identifier (like 56c5c19f94141765119f896c)
     * @param {String} accept application/json
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/DeleteMyselfSuccess}
     */
    this.deleteMyself = function(userId, accept) {
      return this.deleteMyselfWithHttpInfo(userId, accept)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get logged in user data
     * This API can be used to get logged in user data.       This API is especially useful for OAuth authentication, as logged in user data are not sent back to the OAuth client.
     * @param {String} accept application/json
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/GetConnectedUserDataSuccess} and HTTP response
     */
    this.getConnectedUserDataWithHttpInfo = function(accept) {
      var postBody = null;
      // verify the required parameter 'accept' is set
      if (accept === undefined || accept === null) {
        throw new Error("Missing the required parameter 'accept' when calling getConnectedUserData");
      }

      var pathParams = {
      };
      var queryParams = {
      };
      var collectionQueryParams = {
      };
      var headerParams = {
        'accept': accept
      };
      var formParams = {
      };

      var authNames = ['Bearer'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = GetConnectedUserDataSuccess;
      return this.apiClient.callApi(
        '/api/rainbow/enduser/v1.0/users/me', 'GET',
        pathParams, queryParams, collectionQueryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get logged in user data
     * This API can be used to get logged in user data.       This API is especially useful for OAuth authentication, as logged in user data are not sent back to the OAuth client.
     * @param {String} accept application/json
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GetConnectedUserDataSuccess}
     */
    this.getConnectedUserData = function(accept) {
      return this.getConnectedUserDataWithHttpInfo(accept)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get user data by jid_im
     * This API can be used to get a user from its jid_im.       According to the user found, the fields which can be returned (according to the requested format) are not the same.    This depends on logged in user's visibility on the found user (logged in user himself, user visible by logged in user, or user unknown by logged in user).    See documentation of `format` query string parameter for the details of the fields which can be returned.       Example: GET https://openrainbow.com/api/rainbow/enduser/v1.0/users/jids/ 64c84652b5784b1c8fcc4b752fb061d8@openrainbow.com
     * @param {String} jidIm Wanted jid identifier
     * @param {String} accept application/json
     * @param {Object} opts Optional parameters
     * @param {String} opts.format Allows to retrieve more or less user details in response.   * When found user is the logged in user himself, the following fields are returned depending on the requested format:    - `small`: id, loginEmail, firstName, lastName, displayName, companyId, companyName, isTerminated, isInDefaultCompany, calendars, isADSearchAvailable    - `medium`: id, loginEmail, firstName, lastName, displayName, jid_im, jid_tel, companyId, companyName, lastUpdateDate, lastAvatarUpdateDate, isTerminated, guestMode, isInDefaultCompany, calendars, isADSearchAvailable    - `full`: all user fields + isInDefaultCompany, calendars, isADSearchAvailable * When found user is not the logged in user's, but in logged in user's network, logged in user's company or in a company visible by logged in user's company, the following fields are returned depending on the requested format:    - `small`: id, displayName, firstName, lastName, companyId, companyName, isTerminated    - `medium`: id, displayName, firstName, lastName, jid_im, jid_tel, companyId, companyName, isTerminated, lastAvatarUpdateDate, lastUpdateDate, guestMode    - `full`: id, loginEmail, firstName, lastName, displayName, nickName, title, jobTitle, emails, phoneNumbers, country, state, language, timezone, jid_im, jid_tel, companyId, companyName, roles, lastUpdateDate, lastAvatarUpdateDate, isTerminated, guestMode, lastOfflineMailReceivedDate * When found user is unknown by the the logged in user, the following fields are returned depending on the requested format:    - `small`: id, firstName, lastName, companyId, companyName, isTerminated    - `medium`: id, firstName, lastName, companyId, companyName, jid_im, lastAvatarUpdateDate, lastUpdateDate, isTerminated, guestMode    - `full`: id, firstName, lastName, companyId, companyName, jid_im, lastAvatarUpdateDate, lastUpdateDate, isTerminated, guestMode  
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/GetUserByJidSuccess} and HTTP response
     */
    this.getUserByJidWithHttpInfo = function(jidIm, accept, opts) {
      opts = opts || {};
      var postBody = null;
      // verify the required parameter 'jidIm' is set
      if (jidIm === undefined || jidIm === null) {
        throw new Error("Missing the required parameter 'jidIm' when calling getUserByJid");
      }
      // verify the required parameter 'accept' is set
      if (accept === undefined || accept === null) {
        throw new Error("Missing the required parameter 'accept' when calling getUserByJid");
      }

      var pathParams = {
        'jid_im': jidIm
      };
      var queryParams = {
        'format': opts['format'],
      };
      var collectionQueryParams = {
      };
      var headerParams = {
        'accept': accept
      };
      var formParams = {
      };

      var authNames = ['Bearer'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = GetUserByJidSuccess;
      return this.apiClient.callApi(
        '/api/rainbow/enduser/v1.0/users/jids/{jid_im}', 'GET',
        pathParams, queryParams, collectionQueryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get user data by jid_im
     * This API can be used to get a user from its jid_im.       According to the user found, the fields which can be returned (according to the requested format) are not the same.    This depends on logged in user's visibility on the found user (logged in user himself, user visible by logged in user, or user unknown by logged in user).    See documentation of `format` query string parameter for the details of the fields which can be returned.       Example: GET https://openrainbow.com/api/rainbow/enduser/v1.0/users/jids/ 64c84652b5784b1c8fcc4b752fb061d8@openrainbow.com
     * @param {String} jidIm Wanted jid identifier
     * @param {String} accept application/json
     * @param {Object} opts Optional parameters
     * @param {String} opts.format Allows to retrieve more or less user details in response.   * When found user is the logged in user himself, the following fields are returned depending on the requested format:    - `small`: id, loginEmail, firstName, lastName, displayName, companyId, companyName, isTerminated, isInDefaultCompany, calendars, isADSearchAvailable    - `medium`: id, loginEmail, firstName, lastName, displayName, jid_im, jid_tel, companyId, companyName, lastUpdateDate, lastAvatarUpdateDate, isTerminated, guestMode, isInDefaultCompany, calendars, isADSearchAvailable    - `full`: all user fields + isInDefaultCompany, calendars, isADSearchAvailable * When found user is not the logged in user's, but in logged in user's network, logged in user's company or in a company visible by logged in user's company, the following fields are returned depending on the requested format:    - `small`: id, displayName, firstName, lastName, companyId, companyName, isTerminated    - `medium`: id, displayName, firstName, lastName, jid_im, jid_tel, companyId, companyName, isTerminated, lastAvatarUpdateDate, lastUpdateDate, guestMode    - `full`: id, loginEmail, firstName, lastName, displayName, nickName, title, jobTitle, emails, phoneNumbers, country, state, language, timezone, jid_im, jid_tel, companyId, companyName, roles, lastUpdateDate, lastAvatarUpdateDate, isTerminated, guestMode, lastOfflineMailReceivedDate * When found user is unknown by the the logged in user, the following fields are returned depending on the requested format:    - `small`: id, firstName, lastName, companyId, companyName, isTerminated    - `medium`: id, firstName, lastName, companyId, companyName, jid_im, lastAvatarUpdateDate, lastUpdateDate, isTerminated, guestMode    - `full`: id, firstName, lastName, companyId, companyName, jid_im, lastAvatarUpdateDate, lastUpdateDate, isTerminated, guestMode  
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GetUserByJidSuccess}
     */
    this.getUserByJid = function(jidIm, accept, opts) {
      return this.getUserByJidWithHttpInfo(jidIm, accept, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get user data
     * This API can be used to get a user.       According to the user found, the fields which can be returned (according to the requested format) are not the same.    This depends on logged in user's visibility on the found user (logged in user himself, user visible by logged in user, or user unknown by logged in user).    See documentation of `format` query string parameter for the details of the fields which can be returned.       Example: GET https://openrainbow.com/api/rainbow/enduser/v1.0/users/56c5cb38e8078d7512c43985
     * @param {String} userId User unique identifier (like 56c5c19f94141765119f896c)
     * @param {String} accept application/json
     * @param {Object} opts Optional parameters
     * @param {String} opts.format Allows to retrieve more or less user details in response.   * When found user is the logged in user himself, the following fields are returned depending on the requested format:    - `small`: id, loginEmail, firstName, lastName, displayName, companyId, companyName, isTerminated, isInDefaultCompany, calendars, isADSearchAvailable    - `medium`: id, loginEmail, firstName, lastName, displayName, jid_im, jid_tel, companyId, companyName, lastUpdateDate, lastAvatarUpdateDate, isTerminated, guestMode, isInDefaultCompany, calendars, isADSearchAvailable    - `full`: all user fields + isInDefaultCompany, calendars, isADSearchAvailable * When found user is not the logged in user's, but in logged in user's network, logged in user's company or in a company visible by logged in user's company, the following fields are returned depending on the requested format:    - `small`: id, displayName, firstName, lastName, companyId, companyName, isTerminated    - `medium`: id, displayName, firstName, lastName, jid_im, jid_tel, companyId, companyName, isTerminated, lastAvatarUpdateDate, lastUpdateDate, guestMode    - `full`: id, loginEmail, firstName, lastName, displayName, nickName, title, jobTitle, emails, phoneNumbers, country, state, language, timezone, jid_im, jid_tel, companyId, companyName, roles, lastUpdateDate, lastAvatarUpdateDate, isTerminated, guestMode, lastOfflineMailReceivedDate * When found user is unknown by the the logged in user, the following fields are returned depending on the requested format:    - `small`: id, firstName, lastName, companyId, companyName, isTerminated    - `medium`: id, firstName, lastName, companyId, companyName, jid_im, lastAvatarUpdateDate, lastUpdateDate, isTerminated, guestMode    - `full`: id, firstName, lastName, companyId, companyName, jid_im, lastAvatarUpdateDate, lastUpdateDate, isTerminated, guestMode  
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/GetUserDataByIdSuccess} and HTTP response
     */
    this.getUserDataByIdWithHttpInfo = function(userId, accept, opts) {
      opts = opts || {};
      var postBody = null;
      // verify the required parameter 'userId' is set
      if (userId === undefined || userId === null) {
        throw new Error("Missing the required parameter 'userId' when calling getUserDataById");
      }
      // verify the required parameter 'accept' is set
      if (accept === undefined || accept === null) {
        throw new Error("Missing the required parameter 'accept' when calling getUserDataById");
      }

      var pathParams = {
        'userId': userId
      };
      var queryParams = {
        'format': opts['format'],
      };
      var collectionQueryParams = {
      };
      var headerParams = {
        'accept': accept
      };
      var formParams = {
      };

      var authNames = ['Bearer'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = GetUserDataByIdSuccess;
      return this.apiClient.callApi(
        '/api/rainbow/enduser/v1.0/users/{userId}', 'GET',
        pathParams, queryParams, collectionQueryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get user data
     * This API can be used to get a user.       According to the user found, the fields which can be returned (according to the requested format) are not the same.    This depends on logged in user's visibility on the found user (logged in user himself, user visible by logged in user, or user unknown by logged in user).    See documentation of `format` query string parameter for the details of the fields which can be returned.       Example: GET https://openrainbow.com/api/rainbow/enduser/v1.0/users/56c5cb38e8078d7512c43985
     * @param {String} userId User unique identifier (like 56c5c19f94141765119f896c)
     * @param {String} accept application/json
     * @param {Object} opts Optional parameters
     * @param {String} opts.format Allows to retrieve more or less user details in response.   * When found user is the logged in user himself, the following fields are returned depending on the requested format:    - `small`: id, loginEmail, firstName, lastName, displayName, companyId, companyName, isTerminated, isInDefaultCompany, calendars, isADSearchAvailable    - `medium`: id, loginEmail, firstName, lastName, displayName, jid_im, jid_tel, companyId, companyName, lastUpdateDate, lastAvatarUpdateDate, isTerminated, guestMode, isInDefaultCompany, calendars, isADSearchAvailable    - `full`: all user fields + isInDefaultCompany, calendars, isADSearchAvailable * When found user is not the logged in user's, but in logged in user's network, logged in user's company or in a company visible by logged in user's company, the following fields are returned depending on the requested format:    - `small`: id, displayName, firstName, lastName, companyId, companyName, isTerminated    - `medium`: id, displayName, firstName, lastName, jid_im, jid_tel, companyId, companyName, isTerminated, lastAvatarUpdateDate, lastUpdateDate, guestMode    - `full`: id, loginEmail, firstName, lastName, displayName, nickName, title, jobTitle, emails, phoneNumbers, country, state, language, timezone, jid_im, jid_tel, companyId, companyName, roles, lastUpdateDate, lastAvatarUpdateDate, isTerminated, guestMode, lastOfflineMailReceivedDate * When found user is unknown by the the logged in user, the following fields are returned depending on the requested format:    - `small`: id, firstName, lastName, companyId, companyName, isTerminated    - `medium`: id, firstName, lastName, companyId, companyName, jid_im, lastAvatarUpdateDate, lastUpdateDate, isTerminated, guestMode    - `full`: id, firstName, lastName, companyId, companyName, jid_im, lastAvatarUpdateDate, lastUpdateDate, isTerminated, guestMode  
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GetUserDataByIdSuccess}
     */
    this.getUserDataById = function(userId, accept, opts) {
      return this.getUserDataByIdWithHttpInfo(userId, accept, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get user network
     * This API allows to list user's roster.       A field showPresence is added in the response for all users to indicate if the presence is shared between logged in user and this user.
     * @param {String} accept application/json
     * @param {Object} opts Optional parameters
     * @param {String} opts.format Allows to retrieve more or less user details in response.    - `small`: id, firstName, lastName, displayName, companyId, companyName, isTerminated    - `medium`: id, firstName, lastName, displayName, jid_im, jid_tel, companyId, companyName, lastUpdateDate, lastAvatarUpdateDate, isTerminated, guestMode    - `full`: id, firstName, lastName, displayName, nickName, title, jobTitle, emails, phoneNumbers, country, state, language, timezone, jid_im, jid_tel, companyId, companyName, lastUpdateDate, lastAvatarUpdateDate, isTerminated, guestMode, lastOfflineMailReceivedDate
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/GetUserNetworkSuccess} and HTTP response
     */
    this.getUserNetworkWithHttpInfo = function(accept, opts) {
      opts = opts || {};
      var postBody = null;
      // verify the required parameter 'accept' is set
      if (accept === undefined || accept === null) {
        throw new Error("Missing the required parameter 'accept' when calling getUserNetwork");
      }

      var pathParams = {
      };
      var queryParams = {
        'format': opts['format'],
      };
      var collectionQueryParams = {
      };
      var headerParams = {
        'accept': accept
      };
      var formParams = {
      };

      var authNames = ['Bearer'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = GetUserNetworkSuccess;
      return this.apiClient.callApi(
        '/api/rainbow/enduser/v1.0/users/networks', 'GET',
        pathParams, queryParams, collectionQueryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get user network
     * This API allows to list user's roster.       A field showPresence is added in the response for all users to indicate if the presence is shared between logged in user and this user.
     * @param {String} accept application/json
     * @param {Object} opts Optional parameters
     * @param {String} opts.format Allows to retrieve more or less user details in response.    - `small`: id, firstName, lastName, displayName, companyId, companyName, isTerminated    - `medium`: id, firstName, lastName, displayName, jid_im, jid_tel, companyId, companyName, lastUpdateDate, lastAvatarUpdateDate, isTerminated, guestMode    - `full`: id, firstName, lastName, displayName, nickName, title, jobTitle, emails, phoneNumbers, country, state, language, timezone, jid_im, jid_tel, companyId, companyName, lastUpdateDate, lastAvatarUpdateDate, isTerminated, guestMode, lastOfflineMailReceivedDate
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GetUserNetworkSuccess}
     */
    this.getUserNetwork = function(accept, opts) {
      return this.getUserNetworkWithHttpInfo(accept, opts)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Get users by list of loginemail
     * This API allows also to search a list of users by loginEmails.       Only basic fields of users are returned in the response (id, loginEmail, firstName, lastName, companyId, companyName, jid_im, lastAvatarUpdateDate, lastUpdateDate, isTerminated, guestMode).    To retrieve more details about the users, use the APIs [GET /api/rainbow/enduser/v1.0/users/:userId][0] or [GET /api/rainbow/enduser/v1.0/users/jids/{jid_im}][1]      The maximum number of loginEmails allowed to be provided is 1000 (an error is returned if more than 1000 emails are provided in loginEmail array).  [0]: #operation/GetUsersId [1]: #operation/GetUserJid
     * @param {module:model/GetUsersByloginEmails} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/GetUsersByloginEmailsSuccess} and HTTP response
     */
    this.getUsersByloginEmailsWithHttpInfo = function(body) {
      var postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling getUsersByloginEmails");
      }

      var pathParams = {
      };
      var queryParams = {
      };
      var collectionQueryParams = {
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['Bearer'];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = GetUsersByloginEmailsSuccess;
      return this.apiClient.callApi(
        '/api/rainbow/enduser/v1.0/users/loginemails', 'POST',
        pathParams, queryParams, collectionQueryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Get users by list of loginemail
     * This API allows also to search a list of users by loginEmails.       Only basic fields of users are returned in the response (id, loginEmail, firstName, lastName, companyId, companyName, jid_im, lastAvatarUpdateDate, lastUpdateDate, isTerminated, guestMode).    To retrieve more details about the users, use the APIs [GET /api/rainbow/enduser/v1.0/users/:userId][0] or [GET /api/rainbow/enduser/v1.0/users/jids/{jid_im}][1]      The maximum number of loginEmails allowed to be provided is 1000 (an error is returned if more than 1000 emails are provided in loginEmail array).  [0]: #operation/GetUsersId [1]: #operation/GetUserJid
     * @param {module:model/GetUsersByloginEmails} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GetUsersByloginEmailsSuccess}
     */
    this.getUsersByloginEmails = function(body) {
      return this.getUsersByloginEmailsWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Self register a user
     * This api allows a user to self register in Rainbow application.       This API handles the following use cases:   * User can self-register by himself, without invitation to join Rainbow from another user or a from a company administrator. In this case:    * A temporary user token is required to validate that this is well the user who create his account, and that his email address is valid. Field temporaryToken must be used, and invitationId and joinCompanyInvitationId must not be set.   * Clients have to first call [POST /api/rainbow/enduser/v1.0/notifications/emails/self-register][0] so that user receive an email with a temporary token.   * User enters this token and his data (only loginEmail and password are mandatory), and Clients have to call this API ([POST /api/rainbow/enduser/v1.0/users/self-register][1]) with this code and user data. * User can register from an invitation sent by another Rainbow user, in this case:    * This API requires the invitation id to validate that this is well the email invited by the inviting user who send the invitation email. Field invitationId must be used, and temporaryToken and joinCompanyInvitationId must not be set.   * Inviting Rainbow user has to call [POST /api/rainbow/enduser/v1.0/notifications/emails/invite-by-end-user][2] so that invited user receives an email with a link containing the invitation id.   * Invited user clicks on this URL, enters his data (only loginEmail and password are mandatory), and Clients have to call this API ([POST /api/rainbow/enduser/v1.0/users/self-register][1]) with the invitationId coming from the URL query string.   * Once user will finish his initialization (isInitialized false -> true), user will be added in inviting user roster, inviting user will receive the following XMPP message indicating that invitation has been accepted, and both users (invited and inviting) will receive a chat message from each other.      ```html <message type='management' id='122'            from='jid_from@openrainbow.com'            to='jid_to@openrainbow.com'            xmlns='jabber:client'>        <userinvite id='57cd5922d341df5812bbcb72' action=\"update\" type='received' status='sent' xmlns='jabber:iq:configuration'/>    </message> ```   * Note that loginEmail provided by the user can be different than the one being in the invitation. * User can register from an invitation sent by a company administrator to join his company in Rainbow, in this case:    * This API requires the join company invitation id to validate that this is well the email invited by the company administrator who send the invitation email. Field joinCompanyInvitationId must be used, and temporaryToken and invitationId must not be set.   * Company administrator has to call [POST /api/rainbow/admin/v1.0/companies/:companyId/join-companies/invitations][3] so that invited user receives an email with a link containing the join company invitation id.   * Invited user clicks on this URL, enters his data (only loginEmail and password are mandatory), and Clients have to call this API ([POST /api/rainbow/enduser/v1.0/users/self-register][1]) with the joinCompanyInvitationId coming from the URL query string.   * Once user is created, user will be added in administrator's company. All company administrators receive the following XMPP message indicating that invitation has been accepted:        ```html <message type='management' id='122'            from='jid_from@openrainbow.com'            to='jid_to@openrainbow.com'            xmlns='jabber:client'>        <joincompanyinvite action=\"update\" id='582048dfe2e68a79f4979624' status='auto-accepted' type='sent' xmlns='jabber:iq:configuration'/>    </message> ```   * Note that loginEmail provided by the user can be different than the one being in the invitation.     In every cases, if temporaryToken, invitationId or joinCompanyInvitationId are valid, user is created in rainbow (Jabber identifiers (IM and TEL) are generated, vCard is created, default users are added to his roster, and user is created in mongoDB database).       If joinCompanyInvitationId is used, created user it attached to the company related to this invitation.    If joinCompanyInvitationId is not used and loginEmail of registering user matches a company domain (from userSelfRegisterAllowedDomains), created user it attached to this company.    If joinCompanyInvitationId is not used but a pending join company invitation exit for loginEmail of registering user, created user is attached to this company and all company admins of this company are notified with the XMPP message described above that the invitation has been accepted.    Otherwise, created user is attached to a \"Default\" company.       If visibility field is not specified, company visibility is used (company visibility = public => user visibility = public / company visibility = private or organization => user visibility = private)    From **1.53.0**, a user can be embedded in a chat or conference room, as guest, with limited rights until he finalizes his registration. The self-register API is used to embed this kind of user via an 'invitationId'. A user is created with the flag guestMode = true. Now, in case of loginEmail conflict, the http error 409 supplies this flag. \"errorDetails\": \"User with loginEmail = user1@company.com already exists.\", \"errorDetailsCode\": 409000, \"errorDetailsData\": { \"guestMode\": false } From **1.56.0** release, users can give to their coworkers a public URL to share an INSTANT meeting for chat, pstn-conference, webRTC-conference Sharing an unique URL to join the meeting means:   * Each user has a personal UUID. In the api documentation, this UUID is called **openInviteId**. It can be generated on demand. * The public URL is based on this openInviteId (ex: https://web.openrainbow.com/#/invite?invitationId=0fc06e0ce4a849fcbe214ae5e1107417&scenario=public-url) * Refer to /api/rainbow/enduser/v1.0/users/:userId/open-invites/xxxx API(s) to manage the openInviteId  The goal of this api is to embed on the fly a user not yet created as Rainbow user in the room bind with a given openInviteId (body parameter). Many error cases may occur:   * The openInviteId is not valid HTTP error 404 Not Found (detail: 40400) * If no room is currently binded or when the room to join is no more active (deleted or archived), an HTTP error 404 Not Found (detail: 404116) is returned. * If the maximum of users for a room is reached, an HTTP error 403 (detail: 403621 - Forecast a maximum quota reached..) is returned   [0]: #api-enduser_notifications_emails-EmailSelfRegister [1]: #api-enduser_users-enduser_SelfRegisterUsers [2]: #api-enduser_notifications_emails-enduser_InviteByEndUser [3]: /admin/#api-join_company_invitations-admin_PostJoinCompanyInvite
     * @param {module:model/RegisterMyself} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RegisterMyselfSuccess} and HTTP response
     */
    this.registerMyselfWithHttpInfo = function(body) {
      var postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling registerMyself");
      }

      var pathParams = {
      };
      var queryParams = {
      };
      var collectionQueryParams = {
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = RegisterMyselfSuccess;
      return this.apiClient.callApi(
        '/api/rainbow/enduser/v1.0/users/self-register', 'POST',
        pathParams, queryParams, collectionQueryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Self register a user
     * This api allows a user to self register in Rainbow application.       This API handles the following use cases:   * User can self-register by himself, without invitation to join Rainbow from another user or a from a company administrator. In this case:    * A temporary user token is required to validate that this is well the user who create his account, and that his email address is valid. Field temporaryToken must be used, and invitationId and joinCompanyInvitationId must not be set.   * Clients have to first call [POST /api/rainbow/enduser/v1.0/notifications/emails/self-register][0] so that user receive an email with a temporary token.   * User enters this token and his data (only loginEmail and password are mandatory), and Clients have to call this API ([POST /api/rainbow/enduser/v1.0/users/self-register][1]) with this code and user data. * User can register from an invitation sent by another Rainbow user, in this case:    * This API requires the invitation id to validate that this is well the email invited by the inviting user who send the invitation email. Field invitationId must be used, and temporaryToken and joinCompanyInvitationId must not be set.   * Inviting Rainbow user has to call [POST /api/rainbow/enduser/v1.0/notifications/emails/invite-by-end-user][2] so that invited user receives an email with a link containing the invitation id.   * Invited user clicks on this URL, enters his data (only loginEmail and password are mandatory), and Clients have to call this API ([POST /api/rainbow/enduser/v1.0/users/self-register][1]) with the invitationId coming from the URL query string.   * Once user will finish his initialization (isInitialized false -> true), user will be added in inviting user roster, inviting user will receive the following XMPP message indicating that invitation has been accepted, and both users (invited and inviting) will receive a chat message from each other.      ```html <message type='management' id='122'            from='jid_from@openrainbow.com'            to='jid_to@openrainbow.com'            xmlns='jabber:client'>        <userinvite id='57cd5922d341df5812bbcb72' action=\"update\" type='received' status='sent' xmlns='jabber:iq:configuration'/>    </message> ```   * Note that loginEmail provided by the user can be different than the one being in the invitation. * User can register from an invitation sent by a company administrator to join his company in Rainbow, in this case:    * This API requires the join company invitation id to validate that this is well the email invited by the company administrator who send the invitation email. Field joinCompanyInvitationId must be used, and temporaryToken and invitationId must not be set.   * Company administrator has to call [POST /api/rainbow/admin/v1.0/companies/:companyId/join-companies/invitations][3] so that invited user receives an email with a link containing the join company invitation id.   * Invited user clicks on this URL, enters his data (only loginEmail and password are mandatory), and Clients have to call this API ([POST /api/rainbow/enduser/v1.0/users/self-register][1]) with the joinCompanyInvitationId coming from the URL query string.   * Once user is created, user will be added in administrator's company. All company administrators receive the following XMPP message indicating that invitation has been accepted:        ```html <message type='management' id='122'            from='jid_from@openrainbow.com'            to='jid_to@openrainbow.com'            xmlns='jabber:client'>        <joincompanyinvite action=\"update\" id='582048dfe2e68a79f4979624' status='auto-accepted' type='sent' xmlns='jabber:iq:configuration'/>    </message> ```   * Note that loginEmail provided by the user can be different than the one being in the invitation.     In every cases, if temporaryToken, invitationId or joinCompanyInvitationId are valid, user is created in rainbow (Jabber identifiers (IM and TEL) are generated, vCard is created, default users are added to his roster, and user is created in mongoDB database).       If joinCompanyInvitationId is used, created user it attached to the company related to this invitation.    If joinCompanyInvitationId is not used and loginEmail of registering user matches a company domain (from userSelfRegisterAllowedDomains), created user it attached to this company.    If joinCompanyInvitationId is not used but a pending join company invitation exit for loginEmail of registering user, created user is attached to this company and all company admins of this company are notified with the XMPP message described above that the invitation has been accepted.    Otherwise, created user is attached to a \"Default\" company.       If visibility field is not specified, company visibility is used (company visibility = public => user visibility = public / company visibility = private or organization => user visibility = private)    From **1.53.0**, a user can be embedded in a chat or conference room, as guest, with limited rights until he finalizes his registration. The self-register API is used to embed this kind of user via an 'invitationId'. A user is created with the flag guestMode = true. Now, in case of loginEmail conflict, the http error 409 supplies this flag. \"errorDetails\": \"User with loginEmail = user1@company.com already exists.\", \"errorDetailsCode\": 409000, \"errorDetailsData\": { \"guestMode\": false } From **1.56.0** release, users can give to their coworkers a public URL to share an INSTANT meeting for chat, pstn-conference, webRTC-conference Sharing an unique URL to join the meeting means:   * Each user has a personal UUID. In the api documentation, this UUID is called **openInviteId**. It can be generated on demand. * The public URL is based on this openInviteId (ex: https://web.openrainbow.com/#/invite?invitationId=0fc06e0ce4a849fcbe214ae5e1107417&scenario=public-url) * Refer to /api/rainbow/enduser/v1.0/users/:userId/open-invites/xxxx API(s) to manage the openInviteId  The goal of this api is to embed on the fly a user not yet created as Rainbow user in the room bind with a given openInviteId (body parameter). Many error cases may occur:   * The openInviteId is not valid HTTP error 404 Not Found (detail: 40400) * If no room is currently binded or when the room to join is no more active (deleted or archived), an HTTP error 404 Not Found (detail: 404116) is returned. * If the maximum of users for a room is reached, an HTTP error 403 (detail: 403621 - Forecast a maximum quota reached..) is returned   [0]: #api-enduser_notifications_emails-EmailSelfRegister [1]: #api-enduser_users-enduser_SelfRegisterUsers [2]: #api-enduser_notifications_emails-enduser_InviteByEndUser [3]: /admin/#api-join_company_invitations-admin_PostJoinCompanyInvite
     * @param {module:model/RegisterMyself} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RegisterMyselfSuccess}
     */
    this.registerMyself = function(body) {
      return this.registerMyselfWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Remove one contact from the user network
     * This API allows to remove a contact from the user's network. According with RFC 6121 (XMPP instant messaging and presence) the user receives two stanza to warn it two items of the roster are removed        ```html <iq xmlns='jabber:client' to='4084a3b277644118be3403720287f978@openrainbow.com/web_win_1.42.3_nbyfPPcN'  from='4084a3b277644118be3403720287f978@openrainbow.com' type='set'  id='push6688530438275184641'>  <query ver='9cc9aac832027d7a7eeaa15432ab3a8165d35e79' xmlns='jabber:iq:roster'>  <item subscription='remove' jid='tel_9852572291364ec5a7043d68ea72a033@openrainbow.com'>  </query>  <iq>  <iq xmlns='jabber:client'  to='4084a3b277644118be3403720287f978@openrainbow.com/web_win_1.42.3_nbyfPPcN'  from='4084a3b277644118be3403720287f978@openrainbow.com' type='set'  id='push11277218838955800577'>  <query ver='9cc9aac832027d7a7eeaa15432ab3a8165d35e79' xmlns='jabber:iq:roster'>  <item subscription='remove' jid='9852572291364ec5a7043d68ea72a033@openrainbow.com'>  </query>  <iq> ``` If a request to share the contact presence is ongoing, from the user to his contact, it is cancelled and two XMPP events are sent.   One for the user:        ```html <message type='management' id='122'            from='jid_from@openrainbow.com'            to='jid_to@openrainbow.com'            xmlns='jabber:client'>        <presencehandshake id='57cd5922d341df5812bbcb72' action=\"delete\" type='sent' status='canceled' xmlns='jabber:iq:configuration'/>    </message> ```    One for the contact removed:        ```html <message type='management' id='122'            from='jid_from@openrainbow.com'            to='jid_to@openrainbow.com'            xmlns='jabber:client'>        <presencehandshake id='57cd5922d341df5812bbcb72' action=\"delete\" type='received' status='canceled' xmlns='jabber:iq:configuration'/>    </message> ``` For more information about presence subscription, refer to : [POST /api/rainbow/enduser/v1.0/users/:userId/presences][0]  [0]: /enduser/#api-presences-enduser_users_PostPresencesReq
     * @param {String} userId User unique identifier (like 56c5c19f94141765119f896c)
     * @param {String} accept application/json
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/RemoveContactFromUserNetworkSuccess} and HTTP response
     */
    this.removeContactFromUserNetworkWithHttpInfo = function(userId, accept) {
      var postBody = null;
      // verify the required parameter 'userId' is set
      if (userId === undefined || userId === null) {
        throw new Error("Missing the required parameter 'userId' when calling removeContactFromUserNetwork");
      }
      // verify the required parameter 'accept' is set
      if (accept === undefined || accept === null) {
        throw new Error("Missing the required parameter 'accept' when calling removeContactFromUserNetwork");
      }

      var pathParams = {
        'userId': userId
      };
      var queryParams = {
      };
      var collectionQueryParams = {
      };
      var headerParams = {
        'accept': accept
      };
      var formParams = {
      };

      var authNames = ['Bearer'];
      var contentTypes = [];
      var accepts = ['application/json'];
      var returnType = RemoveContactFromUserNetworkSuccess;
      return this.apiClient.callApi(
        '/api/rainbow/enduser/v1.0/users/networks/{userId}', 'DELETE',
        pathParams, queryParams, collectionQueryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Remove one contact from the user network
     * This API allows to remove a contact from the user's network. According with RFC 6121 (XMPP instant messaging and presence) the user receives two stanza to warn it two items of the roster are removed        ```html <iq xmlns='jabber:client' to='4084a3b277644118be3403720287f978@openrainbow.com/web_win_1.42.3_nbyfPPcN'  from='4084a3b277644118be3403720287f978@openrainbow.com' type='set'  id='push6688530438275184641'>  <query ver='9cc9aac832027d7a7eeaa15432ab3a8165d35e79' xmlns='jabber:iq:roster'>  <item subscription='remove' jid='tel_9852572291364ec5a7043d68ea72a033@openrainbow.com'>  </query>  <iq>  <iq xmlns='jabber:client'  to='4084a3b277644118be3403720287f978@openrainbow.com/web_win_1.42.3_nbyfPPcN'  from='4084a3b277644118be3403720287f978@openrainbow.com' type='set'  id='push11277218838955800577'>  <query ver='9cc9aac832027d7a7eeaa15432ab3a8165d35e79' xmlns='jabber:iq:roster'>  <item subscription='remove' jid='9852572291364ec5a7043d68ea72a033@openrainbow.com'>  </query>  <iq> ``` If a request to share the contact presence is ongoing, from the user to his contact, it is cancelled and two XMPP events are sent.   One for the user:        ```html <message type='management' id='122'            from='jid_from@openrainbow.com'            to='jid_to@openrainbow.com'            xmlns='jabber:client'>        <presencehandshake id='57cd5922d341df5812bbcb72' action=\"delete\" type='sent' status='canceled' xmlns='jabber:iq:configuration'/>    </message> ```    One for the contact removed:        ```html <message type='management' id='122'            from='jid_from@openrainbow.com'            to='jid_to@openrainbow.com'            xmlns='jabber:client'>        <presencehandshake id='57cd5922d341df5812bbcb72' action=\"delete\" type='received' status='canceled' xmlns='jabber:iq:configuration'/>    </message> ``` For more information about presence subscription, refer to : [POST /api/rainbow/enduser/v1.0/users/:userId/presences][0]  [0]: /enduser/#api-presences-enduser_users_PostPresencesReq
     * @param {String} userId User unique identifier (like 56c5c19f94141765119f896c)
     * @param {String} accept application/json
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RemoveContactFromUserNetworkSuccess}
     */
    this.removeContactFromUserNetwork = function(userId, accept) {
      return this.removeContactFromUserNetworkWithHttpInfo(userId, accept)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Search a list of users by jid_ims
     * This API allows also to search a list of users by jid_ims.       Only basic fields of users are returned in the response (id, firstName, lastName, companyId, companyName, jid_im, lastAvatarUpdateDate, lastUpdateDate, isTerminated, guestMode).    To retrieve more details about the users, use the APIs [GET /api/rainbow/enduser/v1.0/users/:userId][0] or [GET /api/rainbow/enduser/v1.0/users/jids/{jid_im}][1]      The maximum number of jid_ims allowed to be provided is 1000 (an error is returned if more than 1000 jids are provided in jid_im array).  [0]: #operation/GetUsersId [1]: #operation/GetUserJid
     * @param {module:model/SearchUsersByJids} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/SearchUsersByJidsSuccess} and HTTP response
     */
    this.searchUsersByJidsWithHttpInfo = function(body) {
      var postBody = body;
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling searchUsersByJids");
      }

      var pathParams = {
      };
      var queryParams = {
      };
      var collectionQueryParams = {
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['Bearer'];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = SearchUsersByJidsSuccess;
      return this.apiClient.callApi(
        '/api/rainbow/enduser/v1.0/users/jids', 'POST',
        pathParams, queryParams, collectionQueryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Search a list of users by jid_ims
     * This API allows also to search a list of users by jid_ims.       Only basic fields of users are returned in the response (id, firstName, lastName, companyId, companyName, jid_im, lastAvatarUpdateDate, lastUpdateDate, isTerminated, guestMode).    To retrieve more details about the users, use the APIs [GET /api/rainbow/enduser/v1.0/users/:userId][0] or [GET /api/rainbow/enduser/v1.0/users/jids/{jid_im}][1]      The maximum number of jid_ims allowed to be provided is 1000 (an error is returned if more than 1000 jids are provided in jid_im array).  [0]: #operation/GetUsersId [1]: #operation/GetUserJid
     * @param {module:model/SearchUsersByJids} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/SearchUsersByJidsSuccess}
     */
    this.searchUsersByJids = function(body) {
      return this.searchUsersByJidsWithHttpInfo(body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }


    /**
     * Update user data
     * This API can be used to update data of logged in user. This API can only be used by user himself (i.e. userId of logged in user = value of userId parameter in URL)       A presence stanza is sent to user's resources and users being in user's roster. This allow clients to be notified that this user has been updated:        ```html <presence from='3ae059e2a91c40d9bdd7df0eedc911ca@openrainbow.com'>        <x xmlns='vcard-temp:x:update'>            <data/>        </x>        <actor xmlns='jabber:iq:configuration'/x>    </presence> ```    When user flag isInitialized is set from false to true (end of user registration wizard):   * the user will receive a welcome IM from Emily (translated using user language field is set, otherwise in English) * if the user used the invitationId from an email invitation sent by a Rainbow user:    * invited user and inviting user jid_im are added to mutual rosters   * a conversation entry is created between the invited user and this inviting user, and reciprocally   * an IM message is sent from the invited user to this inviting user (translated using invited user language field is set, otherwise in English)   * the corresponding user invitation is flagged as accepted and both invited user and inviting user are notified with an XMPP message that invitation has been accepted * if the user was invited by one or several Rainbow users, but the user didn't use the invitationId from any email invitations (user registered using a token, use case mostly for the case of mobile apps). In that case, all pending registering invites are automatically accepted:    * invited user and all inviting users jid_im are added to mutual rosters   * conversation entries is created between the invited user and all inviting users, and reciprocally   * an IM message is sent from the invited user to each inviting users (translated using invited user language field is set, otherwise in English)   * the corresponding user invitations are flagged as auto-accepted and both invited user and inviting users are notified with an XMPP message that invitation has been accepted    Note that phone numbers linked to a system (pbx) can't be added in user's phoneNumbers using this API. System phone numbers are created by administrators or by PCG and can be linked to Rainbow user using:    Admin API (administrator only): [PUT /api/rainbow/admin/v1.0/systems/{systemId}/phone-numbers/{phoneNumberId}][0]   From **1.53.0**, a user can be embedded in a chat or conference room, as guest, with limited rights until he finalizes his registration. The self-register API is used to embed this kind of user via an 'invitationId'. A user is created with the flag guestMode = true. This API allows to reset this flag only.  [0]: /admin/#api-systems_phone_numbers-PutSystemPhoneNumbers
     * @param {String} userId User unique identifier (like 56f42c1914e2a8a91b99e595)
     * @param {module:model/UpdateUser} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data of type {@link module:model/UpdateUserSuccess} and HTTP response
     */
    this.updateUserWithHttpInfo = function(userId, body) {
      var postBody = body;
      // verify the required parameter 'userId' is set
      if (userId === undefined || userId === null) {
        throw new Error("Missing the required parameter 'userId' when calling updateUser");
      }
      // verify the required parameter 'body' is set
      if (body === undefined || body === null) {
        throw new Error("Missing the required parameter 'body' when calling updateUser");
      }

      var pathParams = {
        'userId': userId
      };
      var queryParams = {
      };
      var collectionQueryParams = {
      };
      var headerParams = {
      };
      var formParams = {
      };

      var authNames = ['Bearer'];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = UpdateUserSuccess;
      return this.apiClient.callApi(
        '/api/rainbow/enduser/v1.0/users/{userId}', 'PUT',
        pathParams, queryParams, collectionQueryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null
      );
    }

    /**
     * Update user data
     * This API can be used to update data of logged in user. This API can only be used by user himself (i.e. userId of logged in user = value of userId parameter in URL)       A presence stanza is sent to user's resources and users being in user's roster. This allow clients to be notified that this user has been updated:        ```html <presence from='3ae059e2a91c40d9bdd7df0eedc911ca@openrainbow.com'>        <x xmlns='vcard-temp:x:update'>            <data/>        </x>        <actor xmlns='jabber:iq:configuration'/x>    </presence> ```    When user flag isInitialized is set from false to true (end of user registration wizard):   * the user will receive a welcome IM from Emily (translated using user language field is set, otherwise in English) * if the user used the invitationId from an email invitation sent by a Rainbow user:    * invited user and inviting user jid_im are added to mutual rosters   * a conversation entry is created between the invited user and this inviting user, and reciprocally   * an IM message is sent from the invited user to this inviting user (translated using invited user language field is set, otherwise in English)   * the corresponding user invitation is flagged as accepted and both invited user and inviting user are notified with an XMPP message that invitation has been accepted * if the user was invited by one or several Rainbow users, but the user didn't use the invitationId from any email invitations (user registered using a token, use case mostly for the case of mobile apps). In that case, all pending registering invites are automatically accepted:    * invited user and all inviting users jid_im are added to mutual rosters   * conversation entries is created between the invited user and all inviting users, and reciprocally   * an IM message is sent from the invited user to each inviting users (translated using invited user language field is set, otherwise in English)   * the corresponding user invitations are flagged as auto-accepted and both invited user and inviting users are notified with an XMPP message that invitation has been accepted    Note that phone numbers linked to a system (pbx) can't be added in user's phoneNumbers using this API. System phone numbers are created by administrators or by PCG and can be linked to Rainbow user using:    Admin API (administrator only): [PUT /api/rainbow/admin/v1.0/systems/{systemId}/phone-numbers/{phoneNumberId}][0]   From **1.53.0**, a user can be embedded in a chat or conference room, as guest, with limited rights until he finalizes his registration. The self-register API is used to embed this kind of user via an 'invitationId'. A user is created with the flag guestMode = true. This API allows to reset this flag only.  [0]: /admin/#api-systems_phone_numbers-PutSystemPhoneNumbers
     * @param {String} userId User unique identifier (like 56f42c1914e2a8a91b99e595)
     * @param {module:model/UpdateUser} body 
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/UpdateUserSuccess}
     */
    this.updateUser = function(userId, body) {
      return this.updateUserWithHttpInfo(userId, body)
        .then(function(response_and_data) {
          return response_and_data.data;
        });
    }
  };

  return exports;
}));
